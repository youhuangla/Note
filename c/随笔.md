# 机试题目

## 移动

### 测试题

#### 1

数列的定义如下：数列的第一项为n,以后各项为前一项的平方根，求数列的前m项的和。 

输入描述 

输入数据有多组，每组占一行， 由两个整数n(n<10000)和m(m<1000)组成，n和m 的含义如前所述。 

输出描述 

对于每组输入数据，输出该数列的和，每个测试实例占一行，要求精度保留2位小数。请给出C语言代码。

样例输入
81 4
2 2

样例输出
94.73
3.41

（将上述题目翻译为英文



#### 2

春天是鲜花的季节，水仙花就是其中最迷人的代表，数学上有个水仙花数，他是这样定义的：

“水仙花数”是指一个三位数，它的各位数字的立方和等于其本身，比如：

$ 153=1^3 + 5^3 + 3^3$。

现在要求输出所有在m和n范围内的水仙花数。

输入描述

输入数据有多组，每组占一行，包括两个整数m和n(100<=m<=n<=999)

输出描述

对于每个测试实例，要求输出所有在给定范围内的水仙花数，就是说，输出的水仙花数必须大于等于m,并且小于等于n,如果有多个，则要求从小到大排列在一行内输出，之间用一个空格隔开：如果给定的范围内不存在水仙花数，则输出no;每个测试实例的输出占一行。

样例输入

100 120

300 380

样例输出

no

370 371 

### 正式题

#### 1

主串为“ababbbaaabababb”，子串为“abababb”，若使用KMP算法进行匹配，则在第一趟匹配失败后，子串指针需要回退到子串的哪个位置（下标从1开始）（      ）

>   使用 KMP 算法进行匹配时，当子串的某个字符与主串的某个字符不匹配时，需要将子串的指针回退到一个合适的位置，以免漏掉可能的匹配。这个合适的位置就是子串中已经匹配成功的部分中，最长的既是前缀又是后缀的部分的下一位。
>
>   对于给定的主串 "ababbbaaabababb" 和子串 "abababb"，使用 KMP 算法进行匹配时，第一次匹配失败的位置是子串的第 5 位（即子串中的第二个 "a"），此时需要将子串的指针回退到子串的第 3 位（即子串中的第一个 "a"），因为子串中已经匹配成功的部分为 "abab"，其中既是前缀又是后缀的部分为 "ab"，其下一位是子串中的第 3 位。因此，子串指针需要回退到子串的第 3 位。

Ans: 3

#### 2

对于查找表(1,2,3,4,5,6,7,8,9,10,11)采用折半查找，在等概率情况下查找成功的平均查找长度是（      ）

>   折半查找也称为二分查找，是一种在有序数组中查找元素的高效算法。在等概率情况下，查找成功的平均查找长度为 $\log_2(n+1)$，其中 $n$ 是数组的长度。
>
>   对于给定的查找表 (1,2,3,4,5,6,7,8,9,10,11)，长度为 11，因此在等概率情况下，查找成功的平均查找长度为 $\log_2(11+1) \approx 3.4594$（取两位小数）。因此，答案为约等于 3.46（保留两位小数）。

答案：3

#### 3

根据序列（50，25，15，20，75，90）构造二叉排序树，则与之树高相等的满二叉树共有多少个节点

>   在这个问题中，我们需要首先构造一个二叉排序树（BST），然后计算它的高度，最后找到一个与之高度相等的满二叉树的节点数量。首先，我们根据给定的序列（50，25，15，20，75，90）构造一个二叉排序树：
>

>   1.  50 作为根节点
>   2.  25 插入，作为 50 的左子节点
>   3.  15 插入，作为 25 的左子节点
>   4.  20 插入，作为 15 的右子节点
>   5.  75 插入，作为 50 的右子节点
>   6.  90 插入，作为 75 的右子节点
>
>   构建完成后，二叉排序树如下：
>
>   ```
>       50
>      /  \
>     25  75
>    /     \
>   15      90
>    \
>     20
>   ```
>
>   二叉排序树的高度为 4。与之高度相等的满二叉树，高度为 4，共有 2^4 - 1 = 15 个节点。
>
>   所以，与之树高相等的满二叉树共有 15 个节点。









题目描述：
对于两个长度均为 n 的整数序列 a b，定义 $f ( a , b ) = \sum _ { i = 1 } ^ { n } a _ { i } b _ { i }$。

给定a b，现在你可以对a和b各进行一次如下操作：

选择一个正整数 k（0<=k<n）。

将序列的前k个元素取出并加到它的末尾。

特别的，如果k=0则认为没有进行任何操作。

比如a=[1 2 3]，选择k=2，把[1 2]移动到后面，则操作后a变为[3 1 2]。

你需要对a和b各进行一次操作，使得f(a,b)的值最大化。



输入描述
第一行一个正整数 n。

接下来 1 行，每行n个整数 ai 。

接下来 1 行，每行n个整数 bi 。

n<=1000; |ai|,|bi|<=10, 000, 000。

输出描述
每组样例输出一个正整数，表示答案。


样例输入
3
2 3 1
4 5 6
样例输出
32

提示
样例解释

对a的操作：

选择k=2

对b的操作：

选择k=0

操作后：

a=[1 2 3]

b=[4 5 6]

答案是32。给出C++代码





