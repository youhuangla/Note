# 07.Writing Multifile Programs.md

In this lesson, you will learn the syntax for C++ language features that you will need for the next steps in the course. This includes an overview of header files, pointers, build tools, and classes.

## Concept 01: Intro

Welcome to the lesson on writing multi-file programs in C++.

So far in this course,you've written all of your code in a single file.This works well for small programs or while you're prototyping an idea.But as your code-base grows,you'll want the ability to organize your code into multiple files,just as you might have done in other languages you've worked with.

In this lesson you'll learn how to do exactly that.We'll start out with header files and you'll use header files to break a single file into multiple files. Then you'll learn a little bit about build systems which will allow you to efficiently build large programs, and a particular build system we'll cover is CMake and Make.

Then you'll learn some tools for writing larger programs including references,pointers, maps, classes and a little bit of object-oriented programming in C++.You will learn a lot more about object-oriented programming in a later course in this nano degree.But after this lesson,you'll be ready to tackle the route planning project and you'll be prepared to write your own multi-file programs.

![img](img/l4-intro.png)

## Concept 02: Header Files

<img src="img/header-file.png" alt="img" style="zoom:20%;" />

Header files, or `.h` files, allow related f<u>unction, method, and class declarations</u> to be collected in one place. The corresponding definitions can then be placed in `.cpp` files. The compiler considers a header declaration a "promise" that the definition will be found later in the code, so if the compiler reaches a function that hasn't been defined yet, it can continue on compiling until the definition is found. This allows functions to be defined (and declared) in arbitrary order.

### Code

```cpp
/*
Function Order in a Single File
In the following code example, the functions are out of order, and the code will not compile. Try to fix this by rearranging the functions to be in the correct order.
*/


#include <iostream>
using std::cout;


void OuterFunction(int i)
{   
    //you have to define the InnerFunction befre call it.
    InnerFunction(i);
}

void InnerFunction(int i)
{
    cout << "The value of the integer is: " << i << "\n";
}

int main()
{
    int a = 5;
    OuterFunction(a);
}

```

### Solution

```cpp
/*
Function Order in a Single File
In the following code example, the functions are out of order, and the code will not compile. Try to fix this by rearranging the functions to be in the correct order.
*/


#include <iostream>
using std::cout;

void InnerFunction(int i)
{
    cout << "The value of the integer is: " << i << "\n";
}

void OuterFunction(int i)
{   
    //you have to define the InnerFunction befre call it.
    InnerFunction(i);
}


int main()
{
    int a = 5;
    OuterFunction(a);
}

```

```shell
The value of the integer is: 5
```

## Concept 03: Using Headers with Multiple Files

![img](img/c-and-h-2.png)

In the previous concept, you saw how header files could be useful for separating definitions from declarations, so that you don't need to be too careful about the order in which functions are defined. Using header files is typically the first step in creating a multi-file program. In this concept, you will learn about using multiple `.cpp` and `.h` files in a program - how to compile all the files together, and how to ensure the code from one file can be used in another.

### Code

#### Example

header_example.h

```cpp
// The header file with just the function declarations.
// When you click the "Run Code" button, this file will
// be saved as header_example.h.


//include guard
#ifndef HEADER_EXAMPLE_H
#define HEADER_EXAMPLE_H

//don't need variable names, just variable types.
void OuterFunction(int);
void InnerFunction(int);

#endif


/*
NOTE:
The function declarations in the header file don't need variable names, just variable types.
You can put names in the declaration, however, and doing this often makes the code easier to read.
The #include statement for the header used quotes " " around the file name, and not angle brackets <>.
We have stored the header in the same directory as the .cpp file, and the quotes tell the preprocessor
to look for the file in the same directory as the current file - not in the usual set of directories where libraries are typically stored.

Finally, there is a preprocessor directive:
    #ifndef HEADER_EXAMPLE_H
    #define HEADER_EXAMPLE_H
at the top of the header, along with an #endif at the end. This is called an "include guard".
Since the header will be included into another file, and #include just pastes contents into a file,
the include guard prevents the same file from being pasted multiple times into another file.
This might happen if multiple files include the same header, and then are all included into the same main.cpp, for example.
The ifndef checks if HEADER_EXAMPLE_H has not been defined in the file already. If it has not been defined yet,
then it is defined with #define HEADER_EXAMPLE_H, and the rest of the header is used. If HEADER_EXAMPLE_H has already been defined,
then the preprocessor does not enter the ifndef block. Note: There are other ways to do this.
Another common way is to use an #pragma oncepreprocessor directive, but we won't cover that in detail here. See this Wikipedia article for examples.
https://en.wikipedia.org/wiki/Pragma_once
*/

```

main.cpp

```cpp
/*

Using a Header
One other way to solve the code problem above (without rearranging the functions) would have been to declare each function at the top of the file.
A function declaration is much like the first line of a function definition - it contains the return type,
function name, and input variable types. The details of the function definition are not needed for the declaration though.

To avoid a single file from becomming cluttered with declarations and definitions for every function,
it is customary to declare the functions in another file, called the header file.
In C++, the header file will have filetype .h, and the contents of the header file must be included at the top of the .cpp file.
See the following example for a refactoring of the code above into a header and a cpp file.
*/



// The contents of header_example.h are included in
// the corresponding .cpp file using quotes:

//find .h in the same directory as the .cpp file
#include "header_example.h"

#include <iostream>
using std::cout;

void OuterFunction(int i)
{
    InnerFunction(i);
}

void InnerFunction(int i)
{
    cout << "The value of the integer is: " << i << "\n";
}

int main()
{
    int a = 5;
    OuterFunction(a);
}

```

```shell
The value of the integer is: 5
```

#### Test

myhelper.h

```cpp
#ifndef MYHELPER_H
#define MYHELPER_H

#include<vector>
using std::vector;

int IncrementAndComputeVectorSum(vector<int> );
void AddOneToEach(vector<int> &);

#endif

```

main.cpp  

```cpp
#include <iostream>
#include <vector>
#include "myhelper.h"

using std::vector;
using std::cout;



int IncrementAndComputeVectorSum(vector<int> v)
{
    int total = 0;
    AddOneToEach(v);

    for (auto i: v) {
        total += i;
    }
    return total;
}

void AddOneToEach(vector<int> &v)
{
    // Note that the function passes a reference to v
    // and the for loop below uses references to
    // each item in v. This means the actual
    // ints that v holds will be incremented.
    for (auto& i: v) {
        i++;
    }
}

int main()
{
    vector<int> v{1, 2, 3, 4};
    int total = IncrementAndComputeVectorSum(v);
    cout << "The total is: " << total << "\n";
}
```

```shell
The total is: 14
```

## Concept 04: Bjarne on Build Systems

Different organizations have big and elaborate build processes to get their software produced consistently, coherently.
You can repeat the process,and things like that.They vary a bit from organization to organization.It's not really my home territory.

If you use an IDE, it would do simple things simply.When you are starting with C++,that's not probably where you would start.

Then you go to make in CMake and then you may use more specific tool build systems,but really they are somewhat different and you have to learn a few.

## Concept 05: CMake and Make

### Code

info.txt

```txt
CMake and Make
CMake is an open-source, platform-independent build system. CMake uses text documents, labeled as CMakeLists.txt files,
to manage platform-specific build environments, like make.

Unfortunately, an in-depth tutorial on CMake is beyond the scope of this course,
but we can discuss the basics of how CMake works, so you will be ready to use it in your project.


CMakeLists.txt
CMakeList.txt files have a hierarchical structure, and one CMakeList.txt file can be included in each directory of the project.
These files can be used to specify the locations of necessary packages, set build flags and environment variables, specify build target names and locations, and other actions.


CMake Project
A typical CMake project will have a top-level CMakeLists.txt and a build directory. From within the build directory, you could run

root@abc123defg:/my_project/build# cmake ..
root@abc123defg:/my_project/build# make


The first line directs the cmake command at the top-level CMakeLists.txt file with ...
This command uses the top-level CMakeLists.txt to configure the project and create a Makefile.

In the second line, make finds the Makefile and uses the instructions in the Makefile to build the project.


In general, CMake only needs to be run once for a project, unless you are changing build options (e.g. using different build flags).
Make will be able to keep track of which files have changed and compile only those that need to be before building.

```

main.cpp

```cpp
/*
Object Files
So far in this course, we have refered to running g++ as "compiling".

However, g++ performs several distinct tasks:

    1.The preprocessor runs and executes any statement beginning with a hash symbol: #.
        This takes care of any #include statements, for example, so that all code is in place and ready to compile.
    2.Each file in the source code is compiled into an "object file" (a .o file). Object files are platform-specific machine code that will be used to create an executable.
    3.The object files are "linked" together to make a single executable. In the examples you have seen so far, this executable is a.out, but you can specify whatever name you want.

    It is possible to have g++ perform each of the steps separately by using the -c flag.

        g++ -c main.cpp

    will produce a main.o file, and that file can be converted to an executable with

        g++ main.o


Try these commands in the terminal below:

Save the file. The button will save the file as main.cpp
Compile to an object file using the -c flag. You can list the files in the directory with ls.
After compiling, you should see a main.o somewhere in the directory (along with all the notebook files).

Convert the file to an executable with g++.
Run the executable with ./a.out.

*/


#include <iostream>
using std::cout;

int main()
{
    cout << "Hello!" << "\n";
}


/*
Compiling One File of Many

In the example above, you compiled a single source code file to an object file. That object file was then converted into an executable.
If you wanted to do this with many source code files, and your directory only contained the files for your project, your bash commands might look like the following:

root@abc123defg:/home/workspace# g++ -c *.cpp
root@abc123defg:/home/workspace# g++ *.o
root@abc123defg:/home/workspace# ./a.out
Here, the * operator is a wildcard, so any matching file is selected.

But what if you make changes to the code? In that case, you can compile only that file, and use the existing object files from the other source
files for linking. For example, if you only changed file_3.cpp in your code, and all other object files were already created, you could run:

root@abc123defg:/home/workspace# g++ -c file_3.cpp
root@abc123defg:/home/workspace# g++ *.o
root@abc123defg:/home/workspace# ./a.out
As mentioned previously, this works great for small programs, where all the files are easy to find, and you can remember
which ones you have modified. For larger projects, it is helpful to use a build system which can compile the right files for you and take care of linking.

*/

```

## Concept 06: References

You have seen references used previously, in both <u>pass-by-reference</u> <u>for functions,</u> and in a <u>range-based`for` loop</u> example that used references to modify a vector. As you write larger C++ programs, you will find references useful in a variety of situations. In this short notebook, you will see a few more examples of references to solidify your knowledge.

### Code

```cpp
/*
References

As mentioned previously, a reference is another name given to an existing variable.
On the left hand side of any variable declaration, the & operator can be used to declare a reference.
*/


#include <iostream>
using std::cout;

int main()
{
    int i = 1;

    // Declare a reference to i.
    int& j = i;

    //check address
    cout << "i address: " << &i <<",j address: "<< &j<<"\n";

    cout << "The value of j is: " << j << "\n";

    // Change the value of i.
    i = 5;
    cout << "The value of i is changed to: " << i << "\n";
    cout << "The value of j is now: " << j << "\n";

    // Change the value of the reference.
    // Since reference is just another name for the variable,
    // th
    j = 7;
    cout << "The value of j is now: " << j << "\n";
    cout << "The value of i is changed to: " << i << "\n";
}

```

```shell
i address: 0x7fff230df99c,j address: 0x7fff230df99c
The value of j is: 1
The value of i is changed to: 5
The value of j is now: 5
The value of j is now: 7
The value of i is changed to: 7
```

## Concept 07: Pointers

<img src="img/pointer.png" alt="img" style="zoom:20%;" />

Pointers have traditionally been a stumbling block for many students learning C++, but they do not need to be!

A C++ pointer is just a variable that stores the memory address of an object in your program.

That is the most important thing to understand and remember about pointers - they essentially keep track of *where* a variable is stored in the computer's memory.

In the previous lessons, you implemented A* search in a single file without using C++ pointers, except in `CellSort` code that was provided for you; a C++ program can be written without using pointers extensively (or at all). However, pointers give you better control over how your program uses memory. However, much like the pass-by-reference example that you saw previously, it can often be far more efficient to perform an operation with a pointer to an object than performing the same operation using the object itself.

Pointers are an extremely important part of the C++ language, and as you are exposed to more C++ code, you will certainly encounter them. In this notebook, you will become familiar with basic pointers so you get comfortable with the syntax, and you will be ready to use them in the course project code.

### Code

At this point, you might be wondering why the same symbol & can be used to both access memory addresses and,as you've seen before, pass references into a function. This is a great thing to wonder about.The overloading of the <u>ampersand symbol &</u> and the * symbol probably contribute to much of the confusion around pointers.

  The symbols & and * have a different meaning, depending on which side of an equation they appear.

This is extremely important to remember. For the & symbol, if it appears on the <u>left side of an equation</u> (e.g. when declaring a variable), it means that the variable is declared as a **reference**.If the & appears on the <u>right side of an equation</u>, or <u>before a previously defined variable</u>, it is used to return a **memory address**, as in the example above.

```cpp
/*
Accessing a Memory Address
Each variable in a program stores its contents in the computer's memory, and each chunk of the memory has an address number.
For a given variable, the memory address can be accessed using an ampersand in front of the variable.
To see an example of this, execute the following code which displays the hexadecimal memory addresses of the variables i and j:
*/

#include <iostream>
using std::cout;

void Accessing_Memory_Address() {
    cout<< __func__ <<"\n";
    int i = 5;
    int j = 6;

    // Print the memory addresses of i and j
    cout << "The address of i is: " << &i << "\n";
    cout << "The address of j is: " << &j << "\n";
}


/*
At this point, you might be wondering why the same symbol & can be used to both access memory addresses and,
as you've seen before, pass references into a function. This is a great thing to wonder about.
The overloading of the ampersand symbol & and the * symbol probably contribute to much of the confusion around pointers.

    The symbols & and * have a different meaning, depending on which side of an equation they appear.

This is extremely important to remember. For the & symbol, if it appears on the left side of an equation
(e.g. when declaring a variable), it means that the variable is declared as a reference.
If the & appears on the right side of an equation, or before a previously defined variable, 
it is used to return a memory address, as in the example above.


Try using the cell above to create new variables and print out their addresses!

*/


void Storing_Memory_Address_int(){
    cout<< __func__ <<"\n";

    int i = 5;
    // A pointer pointer_to_i is declared and initialized to the address of i.
    int* pointer_to_i = &i;

    // Print the memory addresses of i and j 
    cout << "The address of i is:          " << &i << "\n";
    cout << "The variable pointer_to_i is: " << pointer_to_i << "\n";
    cout << "The address of variable pointer_to_i is: " << &pointer_to_i << "\n";
    //Getting an Object Back from a Pointer Address : de-reference
    cout << "The value of variable pointer_to_i is: " << *pointer_to_i << "\n";
}

void change_value_by_pointer(){
    int i = 5;
    // A pointer pointer_to_i is declared and initialized to the address of i.
    int* pointer_to_i = &i;

    // Print the memory addresses of i and j
    cout << "The address of i is:          " << &i << "\n";
    cout << "The variable pointer_to_i is: " << pointer_to_i << "\n";

    // The value of i is changed.
    i = 7;
    cout << "The new value of the variable i is                     : " << i << "\n";
    cout << "The value of the variable pointed to by pointer_to_i is: " << *pointer_to_i << "\n";
}


int main(){
    Accessing_Memory_Address();
    Storing_Memory_Address_int();
    change_value_by_pointer();
}

```



```shell
Accessing_Memory_Address
The address of i is: 0x7ffe65de8ba0
The address of j is: 0x7ffe65de8ba4
Storing_Memory_Address_int
The address of i is:          0x7ffe65de8b9c
The variable pointer_to_i is: 0x7ffe65de8b9c
The address of variable pointer_to_i is: 0x7ffe65de8ba0
The value of variable pointer_to_i is: 5
The address of i is:          0x7ffe65de8b9c
The variable pointer_to_i is: 0x7ffe65de8b9c
The new value of the variable i is                     : 7
The value of the variable pointed to by pointer_to_i is: 7
```

## Concept 08: Pointers Continued

In the previous concept, you were introduced to `int` pointers, and you learned the syntax for creating a pointer and retrieving an object from a pointer.

In the notebook below, you will see how to create pointers to other object types, and you will learn about how to use pointers with functions.

```cpp
/*
Pointers to Other Object Types
Although the type of object being pointed to must be included in a pointer declaration,
pointers hold the same kind of value for every type of object:

just a memory address to where the object is stored.

In the following code, a vector is declared.

Write your own code to create a pointer to the address of that vector.
Then, dereference your pointer and print the value of the first item in the vector.
*/

#include <iostream>
#include <vector>
using std::cout;
using std::vector;

void pointers_to_objects(){
    cout<< __func__ <<"\n";

    // Vector v is declared and initialized to {1, 2, 3}
    vector<int> v {1, 2, 3};

    // Declare and initialize a pointer to the address of v here:
    vector<int> *pointer_to_v;
    pointer_to_v = &v;

    // The following loops over each int a in the vector v and prints.
    // Note that this uses a "range-based" for loop:
    // https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-for-range
    // ES.71: Prefer a range-for-statement to a for-statement when there is a choice

    for (int a: v) {
        cout << a << "\n";// 1 2 3
    }

    // Dereference your pointer to v and print the int at index 0 here (note: you should print 1):
    for (int i=0; i<v.size();++i) {
        cout << (*pointer_to_v)[i]<< "\n";// 1 2 3
    }
    // Dereference your pointer to v and print the int at index 0 here (note: you should print 1):
    cout << "The first element of v is: " << (*pointer_to_v)[0] << "\n";

}


void AddOne(int* j)
{
    // Dereference the pointer and increment the int being pointed to.
    (*j)++;

    /*
        When using pointers with functions, some care should be taken.
        If a pointer is passed to a function and then assigned to a variable in the function
        that goes out of scope after the function finishes executing, then the pointer
        will have undefined behavior at that point - the memory it is pointing to might be overwritten by other parts of the program.
    */
}

void Passing_Pointers_to_Function(){
    cout<< __func__ <<"\n";

    int i = 1;
    cout << "The value of i is: " << i << "\n";

    // Declare a pointer to i:
    int* pi = &i;
    AddOne(pi);// AddOne is overload! Pass a pointer
    cout << "The value of i is now: " << i << "\n";

}


//pass reference , name is j
int* AddOne(int& j)
{
    // Increment the referenced int and return the
    // address of j.
    j++;
    cout << "The address of j is: " << &j << "\n";

    return &j;
}


void Returning_Pointer_from_Function(){
    cout<< __func__ <<"\n";

    int i = 1;
    cout << "The value of i is: " << i << "\n";

    // Declare a pointer and initialize to the value
    // returned by AddOne:

    int* my_pointer = AddOne(i);// Pass by reference
    cout << "The value of i is now: " << i << "\n";
    cout << "The value of the int pointed to by my_pointer is: " << *my_pointer << "\n";
    //check addr
    cout << "The address of i is: " << &i << "\n";
    cout << "The value of my_pointer is: " << my_pointer << "\n";
    // my_pointer has its own addr
    cout << "The addr of my_pointer is: " << &my_pointer << "\n";

}

int main(){
    pointers_to_objects();
    Passing_Pointers_to_Function();
    Returning_Pointer_from_Function();
}

```

```shell
pointers_to_objects
1
2
3
1
2
3
The first element of v is: 1
Passing_Pointers_to_Function
The value of i is: 1
The value of i is now: 2
Returning_Pointer_from_Function
The value of i is: 1
The address of j is: 0x7ffe490ac11c
The value of i is now: 2
The value of the int pointed to by my_pointer is: 2
The address of i is: 0x7ffe490ac11c
The value of my_pointer is: 0x7ffe490ac11c
The addr of my_pointer is: 0x7ffe490ac120
```

## Concept 09: Bjarne on pointers

Dennis Ritchie had a brilliant idea which was the basic machine model of C. It says that the memory,all the data sequences of objects,and you can refer to them by pointers which are machine addresses with a type.

So fundamentally, a pointer is a machine address and so is,by the way, a reference.In memory, they look the same.A pointer, you then associate the type with it at compile time,so that you know that you're pointing to an integer or pointing to a string or something like that.

The memory model of C, which C++ adopted, is that if you want the integer next to the integers you are pointing to,you can either say plus one or minus one and navigate through the memory.That's what a **pointer** is.It's <u>a machine address with a type associated with it at compile time</u>.

## Concept 10: References vs Pointers

Pointers and references can have similar use cases in C++. As seen previously <u>both references and pointers can be used in pass-by-reference to a function</u>. Additionally, they both provide an alternative way to access an existing variable: pointers through the variable's address, and references through another name for that variable. But what are the <u>differences</u> between the two, and <u>when should each be used</u>? The following list summarizes some of the differences between pointers and references, as well as when each should be used:

| References                                                   | Pointers                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| References must be initialized when they are declared. This means that a reference will always point to data that was <u>intentionally assigned</u> to it. | Pointers can be declared without being initialized, which is <u>dangerous</u>. If this happens mistakenly, the pointer could be pointing to an arbitrary address in memory, and the data associated with that address could be meaningless, leading to undefined behavior and difficult-to-resolve bugs. |
| References <u>can not be null</u>. This means that a reference should <u>point to meaningful data</u> in the program. | Pointers <u>can be null</u>. In fact, if a pointer is not initialized immediately, it is often best practice to initialize to `nullptr`, a special type which indicates that the pointer is null. |
| When used in a function for pass-by-reference, the reference can be <u>used just as a variable of the same type</u> would be. | When used in a function for pass-by-reference, a pointer <u>must be dereferenced</u> in order to access the underlying object. |

References are generally <u>easier and safer</u> than pointers. As a decent rule of thumb, <u>references should be used in place of pointers when possible</u>.

However, there are times when it is <u>not possible to use references</u>. One example is <u>object initialization</u>. You might like one object to store a reference to another object. However, if the other object is not yet available when the first object is created, then the first object will need to use a pointer, not a reference, since a reference cannot be null. The reference could only be initialized once the other object is created.

## Concept 11: Bjarne on References

A lot of the time in code you have to point at some stuff that's over there.One of the reasons is that you don't want to move the stuff around all the time,so you sent what is either called a <u>pointer or reference</u> or what they're.

In C++, a pointer and a reference are roughly the same except that it's <u>easier</u> to use a reference,you don't have to say,
"Go in there and get it",you just use it.It's like a reference in many other languages like Java or such,and furthermore a reference cannot be made to refer to a different object.

If I want to give you a reference to an object and if you're on a reference,and you can now use my object but <u>you can't make your reference point to other objects of mine</u> which you could with a pointer, which comes from C and well in hardware, if you have an address in some place you can give its pointer, you don't know the address.

So that is <u>good for low-level hardware and it's bad for the higher levels</u>.Reference only refers to one thing and that's it.,

## Concept 12: Maps

<img src="img/dictionary.png" alt="img" style="zoom:20%;" />

So far in this course you have seen container data structures, like the `vector` and the `array`. Additionally, you have used classes in your code for this project. Container data structures are fantastic for storing ordered data, and classes are useful for grouping related data and functions together, but neither of these data structures is optimal for storing associated data.

### Dictionary Example

A map (alternatively [hash table](https://en.wikipedia.org/wiki/Hash_table), hash map, or dictionary) is a data structure that uses *key/value* pairs to store data, and provides <u>efficient lookup and insertion</u> of the data. The name "dictionary" should provide an excellent idea of how these work, since a dictionary is a real life example of a map. Here is a slightly edited entry from [www.dictionary.com](https://www.dictionary.com/browse/word?s=t) defining the word "word":

> word
>
> - a unit of language, consisting of one or more spoken sounds or their written representation, that functions as a principal carrier of meaning.
> - speech or talk: to express one's emotion in words.
> - a short talk or conversation: "Marston, I'd like a word with you."
> - an expression or utterance: a word of warning.

### Data Representation

If you were to store this data in your program, you would probably want to be able to quickly look up the definitions using the *key* "word". With a map, a vector of definitions could be stored as the *value* corresponding to the "word" key:

| Key `string` | Value `vector<string>`                                       |
| ------------ | ------------------------------------------------------------ |
| `"word"`     | `<"a unit of language, consisting of one or more spoken sounds or their written representation, that functions as a principal carrier of meaning.", "speech or talk: to express one's emotion in words.", "a short talk or conversation: 'Marston, I'd like a word with you.'", "an expression or utterance: a word of warning.">'` |

In the following notebook, you will learn how to use an `unordered_map`, which is the C++ standard library implementation of a map. Although C++ has several different implementations of map data structures which are similar, `unordered_map` is the structure that you will use in your project.

```cpp
#include <unordered_map>
#include <string>
#include <vector>
#include <iostream>
using namespace std;

int main() {
    unordered_map<int, string> countries{
        {972, "Israel"}, {93, "Afghanistan"}, {355, "Albania"}, {213, "Algeria"}, {376, "Andorra"}, {244, "Angola"}, {54, "Argentina"}, {374, "Armenia"}, {297, "Aruba"}, {61, "Australia"}, {43, "Austria"}, {994, "Azerbaijan"}, {973, "Bahrain"}, {880, "Bangladesh"}, {375, "Belarus"}, {32, "Belgium"}, {501, "Belize"}, {229, "Benin"}, {975, "Bhutan"}, {387, "Bosnia and Herzegovina"}, {267, "Botswana"}, {55, "Brazil"}, {246, "British Indian Ocean Territory"}, {359, "Bulgaria"}, {226, "Burkina Faso"}, {257, "Burundi"}, {855, "Cambodia"}, {237, "Cameroon"}, {1, "Canada"}, {238, "Cape Verde"}, {236, "Central African Republic"}, {235, "Chad"}, {56, "Chile"}, {86, "China"}, {61, "Christmas Island"}, {57, "Colombia"}, {269, "Comoros"}, {242, "Congo"}, {682, "Cook Islands"}, {506, "Costa Rica"}, {385, "Croatia"}, {53, "Cuba"}, {537, "Cyprus"}, {420, "Czech Republic"}, {45, "Denmark"}, {253, "Djibouti"}, {593, "Ecuador"}, {20, "Egypt"}, {503, "El Salvador"}, {240, "Equatorial Guinea"}, {291, "Eritrea"}, {372, "Estonia"}, {251, "Ethiopia"}, {298, "Faroe Islands"}, {679, "Fiji"}, {358, "Finland"}, {33, "France"}, {594, "French Guiana"}, {689, "French Polynesia"}, {241, "Gabon"}, {220, "Gambia"}, {995, "Georgia"}, {49, "Germany"}, {233, "Ghana"}, {350, "Gibraltar"}, {30, "Greece"}, {299, "Greenland"}, {590, "Guadeloupe"}, {502, "Guatemala"}, {224, "Guinea"}, {245, "Guinea-Bissau"}, {595, "Guyana"}, {509, "Haiti"}, {504, "Honduras"}, {36, "Hungary"}, {354, "Iceland"}, {91, "India"}, {62, "Indonesia"}, {964, "Iraq"}, {353, "Ireland"}, {972, "Israel"}, {39, "Italy"}, {81, "Japan"}, {962, "Jordan"}, {254, "Kenya"}, {686, "Kiribati"}, {965, "Kuwait"}, {996, "Kyrgyzstan"}, {371, "Latvia"}, {961, "Lebanon"}, {266, "Lesotho"}, {231, "Liberia"}, {423, "Liechtenstein"}, {370, "Lithuania"}, {352, "Luxembourg"}, {261, "Madagascar"}, {265, "Malawi"}, {60, "Malaysia"}, {223, "Mali"}, {356, "Malta"}, {692, "Marshall Islands"}, {596, "Martinique"}, {222, "Mauritania"}, {230, "Mauritius"}, {262, "Mayotte"}, {52, "Mexico"}, {377, "Monaco"}, {976, "Mongolia"}, {382, "Montenegro"}, {212, "Morocco"}, {95, "Myanmar"}, {264, "Namibia"}, {674, "Nauru"}, {977, "Nepal"}, {31, "Netherlands"}, {599, "Netherlands Antilles"}, {687, "New Caledonia"}, {64, "New Zealand"}, {505, "Nicaragua"}, {227, "Niger"}, {234, "Nigeria"}, {683, "Niue"}, {672, "Norfolk Island"}, {47, "Norway"}, {968, "Oman"}, {92, "Pakistan"}, {680, "Palau"}, {507, "Panama"}, {675, "Papua New Guinea"}, {595, "Paraguay"}, {51, "Peru"}, {63, "Philippines"}, {48, "Poland"}, {351, "Portugal"}, {974, "Qatar"}, {40, "Romania"}, {250, "Rwanda"}, {685, "Samoa"}, {378, "San Marino"}, {966, "Saudi Arabia"}, {221, "Senegal"}, {381, "Serbia"}, {248, "Seychelles"}, {232, "Sierra Leone"}, {65, "Singapore"}, {421, "Slovakia"}, {386, "Slovenia"}, {677, "Solomon Islands"}, {27, "South Africa"}, {500, "South Georgia and the South Sandwich Islands"}, {34, "Spain"}, {94, "Sri Lanka"}, {249, "Sudan"}, {597, "Suriname"}, {268, "Swaziland"}, {46, "Sweden"}, {41, "Switzerland"}, {992, "Tajikistan"}, {66, "Thailand"}, {228, "Togo"}, {690, "Tokelau"}, {676, "Tonga"}, {216, "Tunisia"}, {90, "Turkey"}, {993, "Turkmenistan"}, {688, "Tuvalu"}, {256, "Uganda"}, {380, "Ukraine"}, {971, "United Arab Emirates"}, {44, "United Kingdom"}, {1, "United States"}, {598, "Uruguay"}, {998, "Uzbekistan"}, {678, "Vanuatu"}, {681, "Wallis and Futuna"}, {967, "Yemen"}, {260, "Zambia"}, {263, "Zimbabwe"}, {591, "Bolivia, Plurinational State of"}, {673, "Brunei Darussalam"}, {61, "Cocos (Keeling) Islands"}, {243, "Congo, The Democratic Republic of the"}, {225, "Cote dIvoire"}, {500, "Falkland Islands (Malvinas)"}, {44, "Guernsey"}, {379, "Holy See (Vatican City State)"}, {852, "Hong Kong"}, {98, "Iran, Islamic Republic of"}, {44, "Isle of Man"}, {44, "Jersey"}, {850, "Korea, Democratic People's Republic of"}, {82, "Korea, Republic of"}, {856, "Lao People's Democratic Republic"}, {218, "Libyan Arab Jamahiriya"}, {853, "Macao"}, {389, "Macedonia, The Former Yugoslav Republic of"}, {691, "Micronesia, Federated States of"}, {373, "Moldova, Republic of"}, {258, "Mozambique"}, {970, "Palestinian Territory, Occupied"}, {872, "Pitcairn"}, {262, "Réunion"}, {7, "Russia"}, {590, "Saint Barthélemy"}, {290, "Saint Helena, Ascension and Tristan Da Cunha"}, {590, "Saint Martin"}, {508, "Saint Pierre and Miquelon"}, {239, "Sao Tome and Principe"}, {252, "Somalia"}, {47, "Svalbard and Jan Mayen"}, {963, "Syrian Arab Republic"}, {886, "Taiwan, Province of China"}, {255, "Tanzania, United Republic of"}, {670, "Timor-Leste"}, {58, "Venezuela, Bolivarian Republic of"}, {84, "Viet Nam"}};

    if (countries.find(960) == countries.end()) {
        countries[960] = "Maldives";
    }

    vector<int> codes{44, 353, 960};

    for (int code : codes) {
        cout << countries[code] << endl;
    }
}
```

```shell
United Kingdom
Ireland
Maldives
```

### map::find

 [std::map<Key,T,Compare,Allocator>::find \- cppreference\.com](https://zh.cppreference.com/w/cpp/container/map/find)

```
std::map
```

|                                                              |      |            |
| ------------------------------------------------------------ | ---- | ---------- |
| iterator find( const Key& key );                             | (1)  |            |
| const_iterator find( const Key& key ) const;                 | (2)  |            |
| template< class K > iterator find( const K& x );             | (3)  | (C++14 起) |
| template< class K > const_iterator find( const K& x ) const; | (4)  | (C++14 起) |

1,2) 寻找键等于 `key` 的的元素。

3,4) 寻找键比较*等价*于值 `x` 的元素。此重载仅若有限定标识 Compare::is_transparent 合法并指代类型才参与重载决议。它允许无需构造 `Key` 的实例就调用此函数。

#### 参数

| key  | -    | 要搜索的元素键值             |
| ---- | ---- | ---------------------------- |
| x    | -    | 能通透地与键比较的任何类型值 |

#### 返回值

指向键等于 `key` 的元素的迭代器。若找不到这种元素，则返回尾后（见 [end()](https://zh.cppreference.com/w/cpp/container/map/end) ）迭代器。

#### 复杂度

与容器大小成对数。

## Concept 13: Classes and Object-Oriented Programming

<img src="img/object.png" alt="img" style="zoom: 25%;" />

If you are taking this course, you have probably used <u>object-oriented programming (OOP)</u> previously in another language. If it's been a while since you've used OOP, OOP is a style of coding that <u>collects related data (object *attributes*) and functions (object *methods*) together to form a single data structure, called an *object*</u>. This allows that collection of <u>attributes and methods</u> to be used repeatedly in your program without code repetition.

In C++ the attributes and methods that make up an object are specified in a code *class*, and each object in the program is an *instance* of that class.

This concept is intended to provide you with the basic syntax for writing classes in C++. In this Foundations course, you will not need to write your own classes for the project, but you will be modifying existing classes in the code. You will be writing your own classes in the next course of this Nanodegree: Object-Oriented Programming.

### Code

#### Code without objects

```cpp
/*
Code without Objects
Suppose you were writing a program to model several cars.
In your program, you want to keep track of each car's color and the distance the car has traveled,
and you want to be able to increment this distance and print out the car's properties.

You could write something like the code below to accomplish this:
*/

#include <iostream>
#include <string>
using std::string;
using std::cout;

int main() {
    // Variables to hold each car's color.
    string car_1_color = "green";
    string car_2_color = "red";
    string car_3_color = "blue";

    // Variables to hold each car's initial position.
    int car_1_distance = 0;
    int car_2_distance = 0;
    int car_3_distance = 0;

    // Increment car_1's position by 1.
    car_1_distance++;

    // Print out the position and color of each car.
    cout << "The distance that the " << car_1_color << " car 1 has traveled is: " << car_1_distance << "\n";
    cout << "The distance that the " << car_2_color << " car 2 has traveled is: " << car_2_distance << "\n";
    cout << "The distance that the " << car_3_color << " car 3 has traveled is: " << car_3_distance << "\n";
}

/*
This works for the few cars that are defined in the program,
but if you wanted the program to keep track of many cars this would be cumbersome.
You would need to create a new variables for every car, and the code would quickly become cluttered.
One way to fix this would be to define a Car class with those variables as attributes,
along with a few class methods to increment the distance traveled and print out car data.
*/

```

#### Code with objects

```cpp
#include <iostream>
#include <string>
using std::string;
using std::cout;

// The Car class
class Car {
public:
    // Method to print data.
    void PrintCarData() {
        cout << "The distance that the " << color << " car " << number << " has traveled is: " << distance << "\n";
    }

    // Method to increment the distance travelled.
    void IncrementDistance() {
        distance++;
    }

    // Class/object attributes
    string color;
    int distance = 0;
    int number;
};

int main() {
    // Create class instances for each car.
    Car car_1, car_2, car_3;

    // Set each instance's color.
    car_1.color = "green";
    car_2.color = "red";
    car_3.color = "blue";

    // Set each instance's number.
    car_1.number = 1;
    car_2.number = 2;
    car_3.number = 3;

    // Increment car_1's position by 1.
    car_1.IncrementDistance();

    // Print out the position and color of each car.
    car_1.PrintCarData();
    car_2.PrintCarData();
    car_3.PrintCarData();
}

/*
This looks ok, and you have reduced the number of variables in main, so you might see how this could be more organized going forward.
However, there is now a lot more code than you started with, and the main doesn't seem much more organzied.
The code above still sets the attributes for each car after the car has been created.
*/

```

#### Code with objects and constructor

```cpp
/*
Adding a Constructor
The best way to fix this is to add a constructor to the Car class.
The constructor allows you to instantiate new objects with the data that you want.
In the next code cell, we have added a constructor for Car that allows the number and color to be passed in.
This means that each Car object can be created with those variables.
*/

#include <iostream>
#include <string>
using std::string;
using std::cout;

class Car {
public:
    void PrintCarData() {
        cout << "The distance that the " << color << " car " << number << " has traveled is: " << distance << "\n";
    }

    void IncrementDistance() {
        distance++;
    }

    // Adding a constructor here:
    Car(string c, int n) {
        // Setting the class attributes with
        // The values passed into the constructor.
        color = c;
        number = n;
    }

    string color;
    int distance = 0;
    int number;
};

int main() {
    // Create class instances for each car.
    Car car_1 = Car("green", 1);
    Car car_2 = Car("red", 2);
    Car car_3 = Car("blue", 3);

    // Increment car_1's position by 1.
    car_1.IncrementDistance();

    // Print out the position and color of each car.
    car_1.PrintCarData();
    car_2.PrintCarData();
    car_3.PrintCarData();
}

/*
This is now beginning to look better. 
The main is more organized than when we first started, 
although there is a little more code overall to accomodate the class definition. 
At this point, you might want to separate your class definition into it's own .h and .cpp files. 
We'll do that in the next concept!
*/

```

#### Output

All code output:

```shell
The distance that the green car 1 has traveled is: 1
The distance that the red car 2 has traveled is: 0
The distance that the blue car 3 has traveled is: 0
```



## Concept 14: Classes and OOP Continued

### Code

car_main.cpp

```cpp
#include <iostream>
#include <string>
#include "car.h"
using std::string;
using std::cout;
#include <vector>
using std::vector;

//cmd: g++ -std=c++17 ./car.cpp ./car_main.cpp && ./a.out

void Putting_Class_Definitions_into_Separate_Files(){
    // Create class instances for each car.
    Car car_1 = Car("green", 1);
    Car car_2 = Car("red", 2);
    Car car_3 = Car("blue", 3);

    // Increment car_1's position by 1.
    car_1.IncrementDistance();

    // Print out the position and color of each car.
    car_1.PrintCarData();
    car_2.PrintCarData();
    car_3.PrintCarData();
}


void scall_up_to_see_the_good_OOP(){
    // Create an empty vector of pointers to Cars
    // and a null pointer to a car.
    vector<Car*> car_vect;
    Car* cp = nullptr;

    // The vector of colors for the cars:
    vector<string> colors {"red", "blue", "green"};

    // Create 100 cars with different colors and
    // push pointers to each of those cars into the vector.
    for (int i=0; i < 100; i++) {;
        cp = new Car(colors[i%3], i+1);
        car_vect.push_back(cp);
    }

    // Move each car forward by 1.
    for (Car* cp: car_vect) {
        cp->IncrementDistance();
    }

    // Print data about each car.
    for (Car* cp: car_vect) {
        cp->PrintCarData();
    }
}

int main()
{
    Putting_Class_Definitions_into_Separate_Files();
    scall_up_to_see_the_good_OOP();
}

```

car.cpp

```cpp
#include <iostream>
#include "car.h"

// Method definitions for the Car class.
void Car::PrintCarData()
{
    cout << "The distance that the " << color << " car " << number << " has traveled is: " << distance << "\n";
}

void Car::IncrementDistance()
{
    distance++;
}

```

car.h

```cpp
#ifndef CAR_H
#define CAR_H

#include <string>
using std::string;
using std::cout;

class Car {
  public:
    void PrintCarData();
    void IncrementDistance();

    // Using a constructor list in the constructor:
    Car(string c, int n) : color(c), number(n) {}

  // The variables do not need to be accessed outside of
  // functions from this class, so we can set them to private.
  private:
    string color;
    int distance = 0;
    int number;
};

#endif

```

```shell
The distance that the green car 1 has traveled is: 1
The distance that the red car 2 has traveled is: 0
The distance that the blue car 3 has traveled is: 0
The distance that the red car 1 has traveled is: 1
The distance that the blue car 2 has traveled is: 1
The distance that the green car 3 has traveled is: 1
The distance that the red car 4 has traveled is: 1
The distance that the blue car 5 has traveled is: 1
The distance that the green car 6 has traveled is: 1
The distance that the red car 7 has traveled is: 1
The distance that the blue car 8 has traveled is: 1
The distance that the green car 9 has traveled is: 1
The distance that the red car 10 has traveled is: 1
The distance that the blue car 11 has traveled is: 1
The distance that the green car 12 has traveled is: 1
The distance that the red car 13 has traveled is: 1
The distance that the blue car 14 has traveled is: 1
The distance that the green car 15 has traveled is: 1
The distance that the red car 16 has traveled is: 1
The distance that the blue car 17 has traveled is: 1
The distance that the green car 18 has traveled is: 1
The distance that the red car 19 has traveled is: 1
The distance that the blue car 20 has traveled is: 1
The distance that the green car 21 has traveled is: 1
The distance that the red car 22 has traveled is: 1
The distance that the blue car 23 has traveled is: 1
The distance that the green car 24 has traveled is: 1
The distance that the red car 25 has traveled is: 1
The distance that the blue car 26 has traveled is: 1
The distance that the green car 27 has traveled is: 1
The distance that the red car 28 has traveled is: 1
The distance that the blue car 29 has traveled is: 1
The distance that the green car 30 has traveled is: 1
The distance that the red car 31 has traveled is: 1
The distance that the blue car 32 has traveled is: 1
The distance that the green car 33 has traveled is: 1
The distance that the red car 34 has traveled is: 1
The distance that the blue car 35 has traveled is: 1
The distance that the green car 36 has traveled is: 1
The distance that the red car 37 has traveled is: 1
The distance that the blue car 38 has traveled is: 1
The distance that the green car 39 has traveled is: 1
The distance that the red car 40 has traveled is: 1
The distance that the blue car 41 has traveled is: 1
The distance that the green car 42 has traveled is: 1
The distance that the red car 43 has traveled is: 1
The distance that the blue car 44 has traveled is: 1
The distance that the green car 45 has traveled is: 1
The distance that the red car 46 has traveled is: 1
The distance that the blue car 47 has traveled is: 1
The distance that the green car 48 has traveled is: 1
The distance that the red car 49 has traveled is: 1
The distance that the blue car 50 has traveled is: 1
The distance that the green car 51 has traveled is: 1
The distance that the red car 52 has traveled is: 1
The distance that the blue car 53 has traveled is: 1
The distance that the green car 54 has traveled is: 1
The distance that the red car 55 has traveled is: 1
The distance that the blue car 56 has traveled is: 1
The distance that the green car 57 has traveled is: 1
The distance that the red car 58 has traveled is: 1
The distance that the blue car 59 has traveled is: 1
The distance that the green car 60 has traveled is: 1
The distance that the red car 61 has traveled is: 1
The distance that the blue car 62 has traveled is: 1
The distance that the green car 63 has traveled is: 1
The distance that the red car 64 has traveled is: 1
The distance that the blue car 65 has traveled is: 1
The distance that the green car 66 has traveled is: 1
The distance that the red car 67 has traveled is: 1
The distance that the blue car 68 has traveled is: 1
The distance that the green car 69 has traveled is: 1
The distance that the red car 70 has traveled is: 1
The distance that the blue car 71 has traveled is: 1
The distance that the green car 72 has traveled is: 1
The distance that the red car 73 has traveled is: 1
The distance that the blue car 74 has traveled is: 1
The distance that the green car 75 has traveled is: 1
The distance that the red car 76 has traveled is: 1
The distance that the blue car 77 has traveled is: 1
The distance that the green car 78 has traveled is: 1
The distance that the red car 79 has traveled is: 1
The distance that the blue car 80 has traveled is: 1
The distance that the green car 81 has traveled is: 1
The distance that the red car 82 has traveled is: 1
The distance that the blue car 83 has traveled is: 1
The distance that the green car 84 has traveled is: 1
The distance that the red car 85 has traveled is: 1
The distance that the blue car 86 has traveled is: 1
The distance that the green car 87 has traveled is: 1
The distance that the red car 88 has traveled is: 1
The distance that the blue car 89 has traveled is: 1
The distance that the green car 90 has traveled is: 1
The distance that the red car 91 has traveled is: 1
The distance that the blue car 92 has traveled is: 1
The distance that the green car 93 has traveled is: 1
The distance that the red car 94 has traveled is: 1
The distance that the blue car 95 has traveled is: 1
The distance that the green car 96 has traveled is: 1
The distance that the red car 97 has traveled is: 1
The distance that the blue car 98 has traveled is: 1
The distance that the green car 99 has traveled is: 1
The distance that the red car 100 has traveled is: 1
```



## Concept 15: This Pointer

When working with classes it is often helpful to be able to refer to the current class instance or object. For example, given the following `Car` class from a previous lesson, the `IncrementDistance()` method implicitly refers to the current `Car` instance's `distance` attribute:

```cpp
// The Car class
class Car {
  public:
    // Method to print data.
    void PrintCarData() {
        cout << "The distance that the " << color << " car " << number << " has traveled is: " << distance << "\n";
    }

    // Method to increment the distance travelled.
    void IncrementDistance() {
        distance++;
    }

    // Class/object attributes
    string color;
    int distance = 0;
    int number;
};
```

It is possible to make this explicit in C++ by using the `this` pointer, which points to the current class instance. Using `this` can sometimes be helpful to add clarity to more complicated code:

```cpp
// The Car class
class Car {
  public:
    // Method to print data.
    void PrintCarData() {
        cout << "The distance that the " << this->color << " car " << this->number << " has traveled is: " << this->distance << "\n";
    }

    // Method to increment the distance travelled.
    void IncrementDistance() {
        this->distance++;
    }

    // Class/object attributes
    string color;
    int distance = 0;
    int number;
};
```

Note: you may see `this` used in some code in the remainder of the course.

## Concept 16: How Long Does it Take to Learn C++?

How long does it take to learn C++?

Depends what you want to do and what you already know.If you are already a programmer in quite a few languages,my recommendation is to read the two of C++ second edition.You can do it in a weekend. Now we have the fundamentals and you have to do some experimentation and probably dig deeper into the areas you are interested in.

If you want to do anything, you have to pick up some libraries and learn them.But we're talking days or weeks.But that assumes you're programmer.If I have to explain to you what a linked-list is or what a vector is,or what a hash table is, then it takes much longer.

So if you start from the beginning to reach the professional level,we're talking months and years.

One question I sometime ask is how long does it take to play a violin?

To learn to play a violin?Well, if nobody's listening, it's easy.If only our mother has to appreciate it maybe it'll do fine but otherwise it'll take years.Now, if you're already a violinist and you want to play a viola,you can probably do it in a couple of weeks.Depends what you are,what your background is,what you're already knows and then how good do you want to be at it.If you're thinking about the Lincoln Center,you better spent years.

And the equivalent for a programming language if you want to be the ace program building the next generation infrastructure or the next absolutely great application,you better spend some years learning not just the programming language but your basic computer science and your application areas.

## Concept 17: Outro

Well done. You are now able to break a single file program into multiple files and you've learned some of the tools that will allow you to create larger programs in the future.

Let's do a quick review of what you've learned in this lesson.

We started out this lesson with header files, where you used headers to break a single file into multiple files.Then you learned a little bit about build systems, and in particular you learned about CMake and Make.Finally, you learned some tools for writing larger programs including references,pointers, maps, classes, and a little bit about object oriented programming in C++.
Headers, CMake, pointers, and references,and object-oriented programming are topics you will see over and over again throughout this Nanodegree.

So you'll get a lot more practice with each of them as you continue beyond this course.However, you are now well-prepared to start the final project for the course.Have a look at the next lesson to get started.

<img src="img/l4-outro.png" alt="img" style="zoom:50%;" />

